#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <FL/Fl_Shared_Image.H>
#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#include "timer.h"
#include "idv/world.h"
#include "idv/gl_draw.h"
#endif
// angle of rotation for the camera direction
float angle = 0.0f;
// actual vector representing the camera's direction
float lx=0.0f, lz=-1.0f, ly = 0.0f;
// XZ position of the camera
float x=0.0f, z=5.0f, y=1.75f;
// the key states. These variables will be zero when no key is being pressed
float deltaAngle = 0.0f;
float deltaMove = 0;
int xOrigin = -1;
// width and height of the window
int h,w;
// variables to compute frames per second
int frame;
long runtime, timebase;
char s[50];
// variables to hold window identifiers
int mainWindow, worldWindow;
//border between subwindows
int border = 6;
bool loadExampleWorld = false;

void setProjection(int w1, int h1)
{
	float ratio;
	// Prevent a divide by zero, when window is too short
	// (you can't make a window of zero width).
	if(h1 > 0) {
		ratio = 1.0f * w1 / h1;
	}
	// Reset the coordinate system before modifying
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	// Set the viewport to be the entire window
	glViewport(0, 0, w1, h1);
	// Set the clipping volume
	gluPerspective(45,ratio,0.1,1000);
	glMatrixMode(GL_MODELVIEW);
}
void changeSize(int w1,int h1) {
	if(h1 == 0) {
		h1 = 1;
	}
	// we're keeping these values because we'll need them later
	w = w1;
	h = h1;
	// set subwindow 1 as the active window
	glutSetWindow(worldWindow);
	// resize and reposition the sub window
	//if(loadExampleWorld==true) {
		glutPositionWindow(border,border);
		glutReshapeWindow(w-2*border, h-2*border);
		setProjection(w-2*border, h-2*border);
	//}
}
void drawSnowMan() {
	glColor3f(1.0f, 1.0f, 1.0f);
	// Draw Body
	glTranslatef(0.0f ,0.75f, 0.0f);
	glutSolidSphere(0.75f,20,20);
	// Draw Head
	glTranslatef(0.0f, 1.0f, 0.0f);
	glutSolidSphere(0.25f,20,20);
	// Draw Eyes
	glPushMatrix();
	glColor3f(0.0f,0.0f,0.0f);
	glTranslatef(0.05f, 0.10f, 0.18f);
	glutSolidSphere(0.05f,10,10);
	glTranslatef(-0.1f, 0.0f, 0.0f);
	glutSolidSphere(0.05f,10,10);
	glPopMatrix();
	// Draw Nose
	glColor3f(1.0f, 0.5f, 0.5f);
	glRotatef(0.0f,1.0f, 0.0f, 0.0f);
	glutSolidCone(0.08f,0.5f,10,2);
	glColor3f(1.0f, 1.0f, 1.0f);
}
void renderBitmapString(
	float x,
	float y,
	float z,
	void *font,
	char *string) {
	char *c;
	glRasterPos3f(x, y,z);
	for (c=string; *c != '\0'; c++) {
		glutBitmapCharacter(font, *c);
	}
}
void restorePerspectiveProjection() {
	glMatrixMode(GL_PROJECTION);
	// restore previous projection matrix
	glPopMatrix();
	// get back to modelview mode
	glMatrixMode(GL_MODELVIEW);
}
void setOrthographicProjection() {
	// switch to projection mode
	glMatrixMode(GL_PROJECTION);
	// save previous matrix which contains the
	//settings for the perspective projection
	glPushMatrix();
	// reset matrix
	glLoadIdentity();
	// set a 2D orthographic projection
	gluOrtho2D(0, w, h, 0);
	// switch back to modelview mode
	glMatrixMode(GL_MODELVIEW);
}
void computePos(float deltaMove, float new_angle) {
	x += deltaMove * lx * 0.1f;
	z += deltaMove * lz * 0.1f;
	lx = sin(new_angle);
	lz = -cos(new_angle);
}
// Render Items for test scene to show GLUT working
void renderTestScene() {
	// Draw ground
	glColor3f(0.9f, 0.9f, 0.9f);
	glBegin(GL_QUADS);
	glVertex3f(-100.0f, 0.0f, -100.0f);
	glVertex3f(-100.0f, 0.0f, 100.0f);
	glVertex3f( 100.0f, 0.0f, 100.0f);
	glVertex3f( 100.0f, 0.0f, -100.0f);
	glEnd();
	// Draw 36 SnowMen
	for(int i = -3; i < 3; i++) {
		for(int j=-3; j < 3; j++) {
			glPushMatrix();
			glTranslatef(i*10.0f, 0.0f, j * 10.0f);
			drawSnowMan();
			glPopMatrix();
		}
	}
}
// Display function for main window
void renderScene() {
	glutSetWindow(mainWindow);
	glClear(GL_COLOR_BUFFER_BIT);
	glutSwapBuffers();
}
// Display function for world window
void renderWorld() {
	glutSetWindow(worldWindow);

	if(loadExampleWorld==true) {
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glLoadIdentity();
		gluLookAt(x, y, z, x + lx, y + ly, z + lz, 0.0f, 1.0f, 0.0f);
		Vec3d pos;
		double elev;
		double azim;
		double dolly;
		g_Draw.getCameraView(pos, elev, azim, dolly);
		//gluLookAt(pos[0], pos[1], pos[2], x + lx, y + ly, z + lz, 0.0f, 1.0f, 0.0f);
		renderTestScene();
		// display fps in the top window
		frame++;
		runtime=glutGet(GLUT_ELAPSED_TIME);
		if (runtime - timebase > 1000) {
			sprintf(s,"COVE3D - FPS:%4.2f",
			frame*1000.0/(runtime-timebase));
			timebase = runtime;
			frame = 0;
		}
		setOrthographicProjection();
		glPushMatrix();
		glLoadIdentity();
		renderBitmapString(5,30,0,GLUT_BITMAP_HELVETICA_12,s);
		glPopMatrix();
		restorePerspectiveProjection();
		glutSwapBuffers();
	} else {
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glLoadIdentity();
		//gluLookAt(x, y, z, x + lx, y + ly, z + lz, 0.0f, 1.0f, 0.0f);
		Vec3d pos;
		Vec3d look_at;
		Vec3d cam_pos;
		double elev;
		double azim;
		double dolly;
		look_at = g_Draw.getCamera().getLookAt();
		cam_pos = g_Draw.getCamera().getPos();
		g_Draw.getCameraView(pos, elev, azim, dolly);
		//TO LOOK AT TEST DATA ADDED RIGHT BELOW
		//gluLookAt(pos[0], pos[1], pos[2], x + lx, y + ly, z + lz, 0.0f, 1.0f, 0.0f);
		//gluLookAt(200.0, 200.0, 200.0, x + lx, y + ly, z + lz, 0.0f, 1.0f, 0.0f);
		//gluLookAt(look_at[0], look_at[1], look_at[2], cam_pos[0], cam_pos[1], cam_pos[2], 0.0f, 1.0f, 0.0f);
		gluLookAt(pos[1]-0.24+(ly/10.0), x+(lx/10.0), -45.7+(lz/10.0), look_at[0], look_at[1], look_at[2], 0.0f, 1.0f, 0.0f);
		g_World.updateTerrain();
		g_Draw.drawGL();
		glutSwapBuffers();
		//g_Draw.gotoCameraView(pos, elev, azim, dolly, g_World.getTimeLine().getTime());
		//gluLookAt(pos[0], pos[1], pos[2], x + lx, y + ly, z + lz, 0.0f, 1.0f, 0.0f);
	}
}
// Global render function
void renderSceneAll() {
	// check for keyboard movement
	if (deltaMove || deltaAngle) {
		angle += deltaAngle;
		computePos(deltaMove, angle);
		glutSetWindow(mainWindow);
		glutPostRedisplay();
	}
	renderScene();
	renderWorld();
}
// -----------------------------------
// KEYBOARD
// -----------------------------------
void processNormalKeys(unsigned char key, int xx, int yy) {
	if (key == 27) {
		glutDestroyWindow(mainWindow);
		exit(0);
	}
}
void pressKey(int key, int xx, int yy) {
	switch (key) {
		case GLUT_KEY_UP : deltaMove = 0.5f; break;
		case GLUT_KEY_DOWN : deltaMove = -0.5f; break;
		case GLUT_KEY_LEFT: deltaAngle = -0.03f; break;
		case GLUT_KEY_RIGHT: deltaAngle = 0.03f; break;
	}
	glutSetWindow(mainWindow);
	glutPostRedisplay();
}
void releaseKey(int key, int x, int y) {
	switch (key) {
		case GLUT_KEY_UP :
		case GLUT_KEY_DOWN : deltaMove = 0; break;
		case GLUT_KEY_LEFT :
		case GLUT_KEY_RIGHT : deltaAngle = 0; break;
	}
}
// -----------------------------------
// MOUSE
// -----------------------------------
void mouseMove(int x, int y) {
// this will only be true when the left button is down
	if (xOrigin >= 0) {
		// update deltaAngle
		deltaAngle = (x - xOrigin) * 0.001f;
		// update camera's direction
		//lx = sin(angle + deltaAngle);
		ly = sin(angle + deltaAngle);
		//lz = -cos(angle + deltaAngle);
		glutSetWindow(mainWindow);
		glutPostRedisplay();
	}
}
void mouseButton(int button, int state, int x, int y) {
	// only start motion if the left button is pressed
	if (button == GLUT_LEFT_BUTTON) {
		// when the button is released
		if (state == GLUT_UP) {
			angle += deltaAngle;
			deltaAngle = 0.0f;
			xOrigin = -1;
		}
		else {// state = GLUT_DOWN
			xOrigin = x;
		}
	}
}
// -----------------------------------
// MAIN and INIT
// -----------------------------------
void init() {
	glClearColor(0.2, 0.2, 0.6, 0.0);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_CULL_FACE);
	// register callbacks
	glutIgnoreKeyRepeat(1);
	glutKeyboardFunc(processNormalKeys);
	glutSpecialFunc(pressKey);
	glutSpecialUpFunc(releaseKey);
	glutMouseFunc(mouseButton);
	glutMotionFunc(mouseMove);
}
int main(int argc, char **argv) {
	bool	bRunning = false;
	cout << "Initializing COVE\n";
	g_Env.m_AppPath = "/home/ribells/workspace/test/Debug/datasvr";
	g_Env.m_LocalCachePath = "/cove_temp";
	g_Set.m_StartupFile = "/home/ribells/workspace/test/Debug/datasvr/worlds/Earthquakes.cov";
	cout << "Application folder is " + g_Env.m_AppPath + "\n";
	cout << "Local data folder is " + g_Env.m_AppPath + "\n";
	cout << "Local cache folder is " + g_Env.m_LocalCachePath + "\n";
	cout << "Data server is " + g_Env.m_COVEServerPath + "\n";

	removedir(g_Env.m_LocalCachePath);
	makedir(g_Env.m_LocalCachePath);

	//initialize the gl space
	g_Draw.initState();

	if (!initSceneManager()) {
		cout << "\nProblems initializing OpenGL functions. Application must exit\n";
	} else {
		cout << "\nScene Manager loaded and ready for action.\n";
	}

	cout << "Python scripting is " + (string) (g_Set.m_PythonAvailable ? "" : "not ") + "available\n";

	g_World.cleanDBFileList();

	if (!g_World.readCoveFile(g_Set.m_StartupFile))
	{
		cout << "\nCannot read most recent COVE file: " + g_Set.m_StartupFile;
		cout <<	"\nOpening default workspace " + g_Env.m_DefaultStartFile;
	}

	//init_new_world(); //from COVE main.cpp
	g_Set.m_UpdataLayerTree = true;

	bRunning = true;

	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);
	glutInitWindowPosition(100,100);
	glutInitWindowSize(800,800);
	mainWindow = glutCreateWindow("COVE - GLUT Version");
	// callbacks for main window
	glutDisplayFunc(renderSceneAll);
	glutReshapeFunc(changeSize);
	// Removing the idle function to save CPU and GPU
	//glutIdleFunc(renderSceneAll);
	init();
	// sub windows
	worldWindow = glutCreateSubWindow(mainWindow, border,border,w-2*border, h-2*border);
	glutDisplayFunc(renderWorld);
	init();
	//Play Data Animations
	g_World.getTimeLine().setPlay(true);
	// enter GLUT event processing cycle
	glutMainLoop();
	return 1;
}
